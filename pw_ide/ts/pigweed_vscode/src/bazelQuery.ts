// Copyright 2025 The Pigweed Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

import { spawn } from 'child_process';
import * as path from 'path';
import { getReliableBazelExecutable } from './bazel';

/**
 * Checks if the root BUILD.bazel file contains `pw_compile_commands_generator` targets.
 *
 * @param cwd The working directory to run the query in.
 * @returns Promise<string[]> A list of matching targets, or empty list if none found.
 */
export async function getPreconfiguredTargets(
  cwd: string,
  spawnFn: typeof spawn = spawn,
  bazelBinary: string | undefined = getReliableBazelExecutable(),
): Promise<string[]> {
  if (!bazelBinary) return [];

  return new Promise((resolve) => {
    const env = {
      ...process.env,
      PATH: `${path.dirname(bazelBinary)}:${process.env?.PATH || ''}`,
      BAZELISK_SKIP_WRAPPER: '1',
    };

    // We use `bazel query` to find any target in the root package that was generated by
    // the `pw_compile_commands_generator` macro.
    // We filter by the `pw_compile_commands_generator` tag to avoid picking up internal targets.
    const query =
      'attr(tags, "pw_compile_commands_generator", attr(generator_function, "pw_compile_commands_generator", //:*))';

    const child = spawnFn(bazelBinary, ['query', query, '--output=label'], {
      cwd,
      env,
    });

    let stdout = '';

    child.stdout?.on('data', (data) => {
      stdout += data.toString();
    });

    child.on('close', (code) => {
      if (code !== 0) {
        // If the query fails (e.g. target doesn't exist), we assume it's not preconfigured.
        resolve([]);
        return;
      }

      // If we get any output, it means we found matching targets.
      const targets = stdout
        .trim()
        .split('\n')
        .map((t) => t.trim())
        .filter((t) => t.length > 0);
      resolve(targets);
    });

    child.on('error', () => {
      resolve([]);
    });
  });
}
